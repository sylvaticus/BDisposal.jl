var documenterSearchIndex = {"docs":
[{"location":"efficiencyScores.html#Finding-the-Efficiency-Scores","page":"Efficiency Scores","title":"Finding the Efficiency Scores","text":"","category":"section"},{"location":"efficiencyScores.html","page":"Efficiency Scores","title":"Efficiency Scores","text":"efficiencyScores","category":"page"},{"location":"efficiencyScores.html#BDisposal.efficiencyScores","page":"Efficiency Scores","title":"BDisposal.efficiencyScores","text":"efficiencyScores(gI,gO,bO,bI;retToScale,prodStructure,dirGI,dirBI,dirGO,dirBO,startθ,startμ,startλ)\n\nCompute efficiency indicators and convexity test results considering the joined production of good and bad outputs.\n\nGiven a set of measures of inputs, \"good\" (\"desiderable\") and \"bad\" (\"undesiderable\") outputs for different decision making units, compute their distance to the production frontier, i.e. their degree of efficiency.\n\nParameters:\n\nPositional\ngI: \"Good\" inputs (3D matrix by DMUs, input items and periods)\ngO: \"Good\" outputs (3D matrix by DMUs, input items and periods)\nbO: \"Bad\" outputs (3D matrix by DMUs, input items and periods)\nbI: \"Bad\" inputs (optional 3D matrix by DMUs, input items and periods) [default: empty array]\nKeyword\nretToScale: Wheter the returns to scale should be assumed \"constant\" or \"variable\" (default). Non-convex distance and test is computed   only under the \"variable\" assumption, except for the (0,0,1,-1) distance under multiplicative production function\nprodStructure: Wheter the production structure should be assumed \"additive\" (default) or \"multiplicative\"\ndirGI,dirBI,dirGO,dirBO: The directions toward where to measure the efficiency (see notes) [default: (0,0,1,0)]\nstartθ,startμ,startλ: Initial values in the convex optimisation problem [default: (0,0,1.1)]\n\nReturns:\n\nA named tuple with the following items:\nλs: The efficiency indicators coherent with the convexity test (2D matrix by DMUs and periods)\nλs_convex: The efficiency indicators assuming a convex production frontier (2D matrix by DMUs and periods)\nλs_nonconvex:  The efficiency indicators assuming a non-convex production frontier (2D matrix by DMUs and periods)\nnonConvTest: The result of the non-convexity test (2D matrix of boolean by DMUs and periods). Note that \"true\" here refers to non-convex.\nnonConvTest_value: The value of the non-convexity test (2D matrix by DMUs and periods)\n\nDescription of the function\n\nefficiencyScores() defines environmental efficiency indicators for a set of Decision Making Units (ie., observations). The nature of the DMUs (eg. firms, countries etc.) depends on the aim of the environmental efficiency analysis. All the DMUs are characterized by a set of inputs and outputs separated into undesirable (eg., polluting) and desirable (eg., no polluting) ones. Note that, inputs separation into desirable (eg., non emissions-causing) and undesirable (eg., emissions-causing) compo- nents is optional for the BDisposal package. The BDisposal DEA modelling defines the smallest environmental production process that contains all DMUs informations (in- puts/outputs) and satisfies the B-disposal axiomatic pattern. The BDisposal algorithms for efficiency assessment compute the distance to the best environmental production procedures; ie., to the efficient production frontier. These efficiency indices inherit the structure of additive and multiplicative distance functions. Notice that the BDisposal package computes general shape of additive and multiplicative distance functions. It follows that, the Bdisposal package introduces a flexible framework for environmental efficiency as- sessment, with the possibility to analyse different directions for the distance functions. In addition, the BDisposal package allows to test the (economists’) properties of con- vexity and disposability.\n\nInterpretation of the results\n\nEfficiency indicators\n\nWhen the additive shape of the distance function is greater than 0 then, the produc- tion unit doesn’t operate efficiently. If the additive efficiency score is equal to 0 then, the DMU is efficient. It follows that, the DMU employs one of the best production technology to transform inputs into outputs; ie., the producer is a benchmark for the other observations. A similar reasoning holds for the multiplicative distance functions. If the multiplicative efficiency index is greater than 1 then, the DMU doesn’t perform efficiently. When the multiplicative efficiency score is equal to 1 then, the production unit is a benchmark for the other observations.\n\nConvexity test\n\nWhen the multiplicative test of convexity is greater than 1 (respectively, equal to 1) then, the production process frontier is non convex (respec- tively, convex). If the multiplicative test of disposability is greater than 1 (respectively, equal to 1) then, the frontier of the production set displays B-disposability; ie., there exists costs for undesirable component decrease. A similar reasoning applies for the additive framework. The informations provided by these tests define the shape of the production process boundaries.\n\nNotes:\n\nDirections toward where to measure the efficiency distance can be tuned using the dirGI,dirBI,dirGO and dirBO parameters.\nThe following directions are supported:\nmultiplicative pr. struct.: (-1,0,0,0), (0,-1,0,0), (0,0,1,0), (0,0,0,-1) or (0,0,1,-1)\naddittive pr. struct.: (1,0,0,0), (0,1,0,0), (0,0,1,0) or (0,0,0,1)\nOther directions can be used to compute the direction under the convex frontier assumption, but the convexity test is not performed and, for the multiplicative case, no guarantee is given on solving the underliying (non-linear) problem (different initial value startθ,startμ,startλ can be attempted)\n\n\n\n\n\n","category":"function"},{"location":"prodIndex.html#Finding-the-Production-Indexes","page":"Productivity Index","title":"Finding the Production Indexes","text":"","category":"section"},{"location":"prodIndex.html","page":"Productivity Index","title":"Productivity Index","text":"prodIndex","category":"page"},{"location":"prodIndex.html#BDisposal.prodIndex","page":"Productivity Index","title":"BDisposal.prodIndex","text":"prodIndex(gI,gO,bO,bI;retToScale,prodStructure,convexAssumption,startθ,startμ,startλ)\n\nCompute productivity indexes\n\nGiven a set of measures of inputs, \"good\" (\"desiderable\") and \"bad\" (\"undesiderable\") outputs for different decision making units, compute their productivity indexes improvements (or declines) between consecutive time periods.\n\nParameters:\n\nPositional\ngI: \"Good\" inputs (3D array by DMUs, input items and periods)\ngO: \"Good\" outputs (3D array by DMUs, input items and periods)\nbO: \"Bad\" outputs (3D array by DMUs, input items and periods)\nbI: \"Bad\" inputs (optional 3D array by DMUs, input items and periods) [default: empty array]\nKeyword\nretToScale: Wheter the return to scales should be assumed \"constant\" (default) or \"variable\"\nprodStructure: Wheter the production structure should be assumed \"additive\" (default) or \"multiplicative\"\nconvexAssumption: Wheter a convex production frontier should be assumed [default: true]\n\nReturns:\n\nA named touple where each element is a matrix of production indexes by DMUs and period passages (e.g. \"year2 on year1\" and \"year3 on year2\") or one of their decompositions.\nCurrently the value reported are:\nprodIndexes:          Overall production indexes\nprodIndexes_G:        Decomposition for \"good\" inputs and outputs\nprodIndexes_B:        Decomposition for \"bad\" inputs and outputs\nprodIndexes_T:        Decomposition for the technological component, overall\nprodIndexes_T_O:      Decomposition for the technological component, outputs\nprodIndexes_T_G_O:    Decomposition for the technological component, good outputs\nprodIndexes_T_B_O:    Decomposition for the technological component, bad outputs\nprodIndexes_T_I:      Decomposition for the technological component, inputs\nprodIndexes_T_G_I:    Decomposition for the technological component, good inputs\nprodIndexes_T_B_I:    Decomposition for the technological component, bad inputs\nprodIndexes_E:        Decomposition for the efficiency component, overall\nprodIndexes_E_O:      Decomposition for the efficiency component, outputs\nprodIndexes_E_G_O:    Decomposition for the efficiency component, good output\nprodIndexes_E_B_O:    Decomposition for the efficiency component, bad outputs\nprodIndexes_E_I:      Decomposition for the efficiency component, inputs\nprodIndexes_E_G_I:    Decomposition for the efficiency component, good inputs\nprodIndexes_E_B_I:    Decomposition for the efficiency component, bad inputs\nprodIndexes_S:        Decomposition for the scale (residual) component, overall\nprodIndexes_S_O:      Decomposition for the scale (residual) component, outputs\nprodIndexes_S_G_O:    Decomposition for the scale (residual) component, good output\nprodIndexes_S_B_O:    Decomposition for the scale (residual) component, bad outputs\nprodIndexes_S_I:      Decomposition for the scale (residual) component, inputs\nprodIndexes_S_G_I:    Decomposition for the scale (residual) component, good inputs\nprodIndexes_S_B_I:    Decomposition for the scale (residual) component, bad inputs\n\nThe second and third element of the tuple are respectively the \"good inputs/outputs\" and \"bad/inputs/outputs\" components. The first matrix can be retrieved from the two components by multiplying them (for multiplicative production structure) or summing them (for additive production strucure).\n\nDescription of the function\n\nprodIndex() displays environmental productivity indices. These productivity measures are implemented for different time periods (eg., years, months etc.) or spatial units (eg., countries, cities etc.), based on the  environmental efficiency indicators described in efficiencyScores. Hence, the environmental productivity indices inherit the structure of additive and multiplicative productivity measures.\n\nInterpretation of the results\n\nThe additive productivity indicator shows combined desirable and undesirable outputs productivity improvement (respectively decline) when it takes positive (respectively negative) values. In the multiplicative context, if the productivity measure is greater (respectively lesser) than 1 then, desirable and undesirable outputs productivity increase (respectively decrease) arises. The BDisposal package underscores the prominent sources of environmental productivity change. The main drivers of productivity variation are technological change, technical efficiency variation and scale efficiency change. For the additive background, when the technological change is greater (respectively, lesser) than 0 then, technolog- ical improvement (respectively, deterioration) occurs. A similar reasoning applies for the additive technical and scale efficiency components. In the multiplicative context, if the technological change is greater (respectively, lesser) than 1 then, technological in- crease (respectively, decrrease) arises. A similar reasonnng applies for the multiplicative technical and scale efficiency components.\n\nExample:\n\njulia> using BDisposal\njulia> # 2 DMUs, 2 good Inputs, 2 bad inputs, 3 good outputs and 2 bad outputs. 2 periods\n       gI = [1; 3; 5;; 2; 4; 5;;; 1; 4; 5;; 2; 5; 5];\njulia> bI = [2; 4; 2;; 3; 7; 5;;; 2; 3; 2;; 3; 6; 5];\njulia> gO = [10; 30; 50;; 20; 40; 50;; 15; 8; 12;;; 12; 40; 50;; 22; 50; 50;; 16; 55; 55];\njulia> bO = [2; 4; 2;; 3; 7; 5;;; 2; 3; 2;; 3; 6; 5];\njulia> analysis = prodIndex(gI,gO,bO,bI,retToScale=\"variable\",convexAssumption=false);\njulia> analysis.prodIndexes\n3×1 Matrix{Union{Missing, Float64}}:\n 1.131370849898476\n 3.5322587464470736\n 2.140872096444188\n\nNotes:\n\nThe decomposition by technological, efficiency and scale components is done only for the convex assumption,\n\nas in the non-convex case the individual distance components used to compute these disaggregations are infinite.\n\n\n\n\n\n","category":"function"},{"location":"individualDMUProblem.html#Individual-DMU-Problem","page":"Vanilla DEA on individual DMU","title":"Individual DMU Problem","text":"","category":"section"},{"location":"individualDMUProblem.html","page":"Vanilla DEA on individual DMU","title":"Vanilla DEA on individual DMU","text":"dmuEfficiency","category":"page"},{"location":"individualDMUProblem.html#BDisposal.dmuEfficiency","page":"Vanilla DEA on individual DMU","title":"BDisposal.dmuEfficiency","text":" dmuEfficiency(I₀,O₀,I,O)\n\nCompute the efficiency score for a DMU using vanilla Data Envelope Analysis.\n\nParameters:\n\nI₀: This DMU inputs (nI)\nO₀: This DMU outputs (n0)\nI: All DMUs inputs (nDMU x nI)\nO: All DMUs outputs (nDMU x n0)\n\nReturns:\n\nA named tuple with:\ncomputed: a boolean to indicase wheter the underlying optimisation succeeded\neff: a boolean to indicate if the DMU is efficient or not\nobj: a scalar representing the efficiency score of the DMU\nwI: a vector of the optimal input weights\nwO: a vector of the optimal output weights\nrefSet: a dictionary having as key the numeral of the reference DMUs and\nvalues the relative constraint duals\n\n\n\n\n\n","category":"function"},{"location":"individualDMUProblem.html","page":"Vanilla DEA on individual DMU","title":"Vanilla DEA on individual DMU","text":"dmuEfficiencyDual","category":"page"},{"location":"individualDMUProblem.html#BDisposal.dmuEfficiencyDual","page":"Vanilla DEA on individual DMU","title":"BDisposal.dmuEfficiencyDual","text":" dmuEfficiencyDual(I₀,O₀,I,O)\n\nCompute the efficiency score for a DMU using vanilla Data Envelope Analysis in the dual representation using the two pass method.\n\nParameters:\n\nI₀: This DMU inputs (nI)\nO₀: This DMU outputs (n0)\nI: All DMUs inputs (nDMU x nI)\nO: All DMUs outputs (nDMU x n0)\n\nReturns:\n\nA named tuple with:\ncomputed: a boolean to indicase wheter the underlying optimisation succeeded\neff: a boolean to indicate if the DMU is efficient or not\nobj: a scalar representing the efficiency score of the DMU\nλ\nθ\ndualsI\ndualsO\ns⁻\ns⁺\n\n\n\n\n\n","category":"function"},{"location":"index.html#![BDisposalLogos](assets/BDisposal_logo_30x30.png)-BDisposal.jl-Documentation","page":"Index","title":"(Image: BDisposalLogos) BDisposal.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Welcome to the documentation for the Non parametric productivity analysis under the B-disposal assumption package.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The BDisposal package proposes a serie of environmental efficiency and productivity algorithms for non-parametric modelling when we relax the disposability assumption of some of the outputs and/or inputs (e.g. pollution). These efficiency and productivity measures are implemented through convex and non convex Data Envelopment Analysis (DEA) (aka Frontier Efficiency Analysis) models.","category":"page"},{"location":"index.html#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Install the BDisposal package with:","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"] add BDisposal.jl","category":"page"},{"location":"index.html#Loading-the-module(s)","page":"Index","title":"Loading the module(s)","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"using BDisposal","category":"page"},{"location":"index.html#Usage","page":"Index","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"The BDisposal package contains two prominent components. First, the BDisposal package defines environmental efficiency indicators for a set of Decision Making Units (efficiencyScores()), computing the distance to the best environmental production procedures, i.e., to the efficient production frontier. Second, the BDisposal package displays environmental productivity indices (prodIndex()). These productivity measures are implemented for different time periods (eg., years, months etc.) or spatial units (eg., countries, cities etc.), based on the aforementioned environmental efficiency indicators.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"Both components can consider constant or variable returns to scale, convex or non-convex production frontiers and additive or multiplicative distance functions, and work with multiple \"good\" (\"desirable\") and \"bad\" (\"undesirable\") inputs and outputs (with undesirable inputs being optional) (not all combinations are implemented, see the individual functions for details and limitations).","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"They are detailed in their respective pages:","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"efficiencyScores: Compute efficiency indicators and convexity test results;\nprodIndex: Compute productivity indexes;\nprodIndexFB: Compute productivity indexes under a provided fixed base;","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The package provides also a couple of functions to compute individual DMU problem using \"vanilla\" DEA (without considering the beta disposability assumption), dmuEfficiency and dmuEfficiencyDual.","category":"page"},{"location":"index.html#Examples","page":"Index","title":"Examples","text":"","category":"section"},{"location":"index.html#Airport-example","page":"Index","title":"Airport example","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"The following example (with data from Abad and Briec, 2019) show how to compute the efficiency indicators for 14 main French airports, where the (good) inputs considered are employees and totalCosts and the (single in this case) bad and good outputs are respectively (airport) co2emissions and passengers.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"using DataFrames, CSV, BDisposal\nprintln(\"Estimating French airports efficiency and productivity indexes...\")\n\n# Loading airport data and preparing the data..\n# Data is stored as a  CSV files with 6 columns: period, dmu, co2emissions, passengers, employees, totalCosts\nairportData = CSV.read(joinpath(dirname(pathof(BDisposal)),\"..\",\"test\",\"data\",\"airports.csv\"),DataFrame; delim=';',copycols=true)\nairportGoodInputs  = [\"employees\",\"totalCosts\"]\nairportBadInputs   = []\nairportGoodOutputs = [\"passengers\"]\nairportBadOutputs  = [\"co2emissions\"]\nsort!(airportData, [:period, :dmu]) # sort data by period and dmu\nperiods = unique(airportData.period)\ndmus    = unique(airportData.dmu)\n\nnGI, nBI, nGO, nBO, nPer, nDMUs,  = length(airportGoodInputs), length(airportBadInputs), length(airportGoodOutputs), length(airportBadOutputs), length(periods),length(dmus)\n\n# Setting empty containers for our data\n# Each of them is a 3D matrix where the first dimension is the decision units, the second one is the individual input or output item and the third dimension is the period to which the data refer\ngI = Array{Float64}(undef, (nDMUs,nGI,nPer)) # Good inputs\nbI = Array{Float64}(undef, (nDMUs,nBI,nPer)) # Bad inputs (optional)\ngO = Array{Float64}(undef, (nDMUs,nGO,nPer)) # Good outputs, aka \"desiderable\" outputs\nbO = Array{Float64}(undef, (nDMUs,nBO,nPer)) # Bad outputs, aka \"undesiderable\" outputs\n# Transferring data to the containers\nfor (p,period) in enumerate(periods)\n    periodData = airportData[airportData.period .== period,:]\n    gI[:,:,p] = Matrix(periodData[:,airportGoodInputs])\n    if nBI > 0\n         bI[:,:,p] = Matrix(periodData[:,airportBadInputs])\n    end\n    gO[:,:,p] = Matrix(periodData[:,airportGoodOutputs])\n    bO[:,:,p] = Matrix(periodData[:,airportBadOutputs])\nend\n\n# Call the function to get the efficiency measurements for constant returns to scale\n(λ, λ_convex, λ_nonconvex, nonConvTest, nonConvTest_value) = efficiencyScores(\n  gI,gO,bO,bI,retToScale=\"constant\", dirGI=0,dirBI=0,dirGO=1,dirBO=-1, prodStructure=\"multiplicative\")\n\n\n# Add periods as headers and decision making names as first column in order to show the data\n# Efficiency Indexes\nλ = hcat(dmus,λ)\nλdf = DataFrame(λ , Symbol.(vcat(\"DMU\",periods)))","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"│ Row │ DMU                      │ 2007    │ 2008    │ 2009    │ 2010    │ 2011    │\n│     │ Any                      │ Any     │ Any     │ Any     │ Any     │ Any     │\n├─────┼──────────────────────────┼─────────┼─────────┼─────────┼─────────┼─────────┤\n│ 1   │ Beauvais                 │ 1.0     │ 1.0     │ 1.0     │ 1.0     │ 1.0     │\n│ 2   │ Bordeaux-Mérignac        │ 1.0     │ 1.0     │ 1.0     │ 1.0     │ 1.0     │\n│ 3   │ Bâle-Mulhouse            │ 1.08295 │ 1.08777 │ 1.17694 │ 1.15278 │ 1.0     │\n│ 4   │ Lille                    │ 1.13183 │ 1.15032 │ 1.06293 │ 1.0     │ 1.0     │\n│ 5   │ Lyon-Saint Exupéry       │ 1.09567 │ 1.07909 │ 1.06901 │ 1.10468 │ 1.00911 │\n│ 6   │ Marseille-Provence       │ 1.00071 │ 1.04287 │ 1.0     │ 1.0     │ 1.0     │\n│ 7   │ Montpellier-Méditerranée │ 1.0     │ 1.0     │ 1.0     │ 1.10249 │ 1.14045 │\n│ 8   │ Nantes-Atlantique        │ 1.09003 │ 1.05685 │ 1.0013  │ 1.05295 │ 1.07531 │\n│ 9   │ Nice-Côte d'azur         │ 1.0     │ 1.02201 │ 1.02562 │ 1.08272 │ 1.02654 │\n│ 10  │ Paris CDG                │ 1.14695 │ 1.14915 │ 1.15329 │ 1.17032 │ 1.17137 │\n│ 11  │ Paris ORY                │ 1.21574 │ 1.22947 │ 1.21526 │ 1.22424 │ 1.21444 │\n│ 12  │ Strasbourg-Entzheim      │ 1.0     │ 1.14408 │ 1.13534 │ 1.23498 │ 1.27062 │\n│ 13  │ Toulouse-Blagnac         │ 1.0     │ 1.0     │ 1.0     │ 1.01143 │ 1.0     │","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"# Non-convexity test\nnc_test = hcat(dmus,nonConvTest)\nnc_test_df = DataFrame(nc_test , Symbol.(vcat(\"DMU\",periods)))","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"│ Row │ DMU                      │ 2007 │ 2008 │ 2009 │ 2010 │ 2011 │\n│     │ Any                      │ Any  │ Any  │ Any  │ Any  │ Any  │\n├─────┼──────────────────────────┼──────┼──────┼──────┼──────┼──────┤\n│ 1   │ Beauvais                 │ 1    │ 1    │ 1    │ 1    │ 1    │\n│ 2   │ Bordeaux-Mérignac        │ 1    │ 1    │ 1    │ 1    │ 1    │\n│ 3   │ Bâle-Mulhouse            │ 0    │ 0    │ 0    │ 0    │ 1    │\n│ 4   │ Lille                    │ 0    │ 0    │ 0    │ 1    │ 1    │\n│ 5   │ Lyon-Saint Exupéry       │ 1    │ 1    │ 1    │ 0    │ 1    │\n│ 6   │ Marseille-Provence       │ 1    │ 0    │ 1    │ 1    │ 1    │\n│ 7   │ Montpellier-Méditerranée │ 1    │ 1    │ 1    │ 1    │ 1    │\n│ 8   │ Nantes-Atlantique        │ 0    │ 0    │ 1    │ 1    │ 1    │\n│ 9   │ Nice-Côte d'azur         │ 1    │ 1    │ 1    │ 1    │ 1    │\n│ 10  │ Paris CDG                │ 0    │ 0    │ 0    │ 0    │ 0    │\n│ 11  │ Paris ORY                │ 0    │ 0    │ 0    │ 0    │ 0    │\n│ 12  │ Strasbourg-Entzheim      │ 1    │ 1    │ 1    │ 1    │ 1    │\n│ 13  │ Toulouse-Blagnac         │ 1    │ 1    │ 1    │ 0    │ 1    │","category":"page"},{"location":"index.html#OECD-Example","page":"Index","title":"OECD Example","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Here we compute the productivity indexes of various OECD countries (with data from Jeon and Sickles (2004)) in terms of gdp growth over traditional production inputs as capital and labour, but also considering CO2 emissions and energy use.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"using DataFrames, CSV, BDisposal\n\n# Loading data and formatting them in the way required by `prodIndex`\ndata = CSV.read(joinpath(dirname(pathof(BDisposal)),\"..\",\"test\",\"data\",\"js-data\",\"oecd.txt\"),DataFrame; delim=' ',ignorerepeated=true,copycols=true,header=false)\nrename!(data,[:ccid,:year,:gdp,:co2,:capital,:labour,:energy])\ndmuMap = Dict(1 => \"Canada\", 2 => \"the United States\", 3 => \"Japan\", 4 => \"Austria\",\n              5 => \"Belgium\", 6 => \"Denmark\", 7 => \"Finland\", 8 => \"France\", 9 => \"Germany\",\n              10 => \"Greece\", 11 => \"Ireland\", 12 => \"Italy\", 13 => \"Norway\", 14 => \"Spain\",\n              15 => \"Sweden\", 16 => \"U.K.\", 17 => \"Australia\")\ndata.ccid = map(x->dmuMap[x], data.ccid)              \n\ngoodInputsLabels  = [\"capital\",\"labour\"]\nbadInputsLabels   = [\"energy\"]\ngoodOutputsLabels = [\"gdp\"]\nbadOutputsLabels  = [\"co2\"]\nsort!(data, [:year, :ccid]) # sort data by period and dmu\nperiods = unique(data.year)\ndmus    = unique(data.ccid)\n\nnGI, nBI, nGO, nBO, nPer, nDMUs,  = length(goodInputsLabels), length(badInputsLabels), length(goodOutputsLabels), length(badOutputsLabels), length(periods),length(dmus)\n\ngI = Array{Float64}(undef, (nDMUs,nGI,nPer))\nbI = Array{Float64}(undef, (nDMUs,nBI,nPer))\ngO = Array{Float64}(undef, (nDMUs,nGO,nPer))\nbO = Array{Float64}(undef, (nDMUs,nBO,nPer))\n\nfor (p,period) in enumerate(periods)\n    periodData = data[data.year .== period,:]\n    gI[:,:,p] = Matrix{Float64}(periodData[:,goodInputsLabels])\n    if nBI > 0\n        bI[:,:,p] =\n         Matrix{Float64}(periodData[:,badInputsLabels])\n    end\n    gO[:,:,p] = Matrix{Float64}(periodData[:,goodOutputsLabels])\n    bO[:,:,p] = Matrix{Float64}(periodData[:,badOutputsLabels])\nend\n\n# Performing the analysis\noecdAnalysis  = prodIndex(gI,gO,bO,bI;\n                   retToScale=\"variable\",prodStructure=\"multiplicative\",convexAssumption=true)\n\n# Showing production indexes for all countries..\npIdx = oecdAnalysis.prodIndexes\n\n# Add periods as headers and decision making names as first column in order to show the data\n# Efficiency Indexes\npIdx  = hcat(dmus,pIdx)\npIdxDf = DataFrame(pIdx, Symbol.(vcat(\"Country\",periods[2:end])))","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"│ Row │ Country           │ 1981     │ 1982     │ 1983     │ 1984     │ 1985     │ 1986     │ 1987     │ 1988     │ 1989     │ 1990     │\n│     │ Any               │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │\n├─────┼───────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤\n│ 1   │ Australia         │ 0.980615 │ 0.874619 │ 1.07314  │ 0.946456 │ 0.913121 │ 0.971135 │ 0.952049 │ 0.963533 │ 0.891746 │ 0.869411 │\n│ 2   │ Austria           │ 0.950153 │ 1.13918  │ 1.08687  │ 0.861064 │ 0.996057 │ 0.96336  │ 1.04583  │ 1.02559  │ 1.00891  │ 0.930929 │\n│ 3   │ Belgium           │ 0.997489 │ 1.12907  │ 1.18585  │ 0.964121 │ 0.957716 │ 0.985223 │ 1.0288   │ 1.06768  │ 0.972852 │ 0.957646 │\n│ 4   │ Canada            │ 1.08493  │ 1.02772  │ 1.01386  │ 0.964103 │ 0.931114 │ 1.02906  │ 0.959126 │ 0.877363 │ 0.938174 │ 1.02891  │\n│ 5   │ Denmark           │ 1.13549  │ 1.17356  │ 1.13089  │ 0.961468 │ 0.811909 │ 1.03924  │ 0.949642 │ 1.08736  │ 1.00549  │ 1.08056  │\n│ 6   │ Finland           │ 1.03238  │ 1.24164  │ 1.06111  │ 1.02071  │ 0.911113 │ 0.979476 │ 0.919278 │ 1.06038  │ 0.987295 │ 0.947106 │\n│ 7   │ France            │ 1.1395   │ 1.09728  │ 0.999966 │ 1.03334  │ 0.960895 │ 1.08548  │ 1.0046   │ 1.10412  │ 0.90306  │ 0.9627   │\n│ 8   │ Germany           │ 1.07873  │ 1.02427  │ 1.00385  │ 0.987006 │ 0.983202 │ 0.967011 │ 1.03386  │ 1.03729  │ 1.03669  │ 0.981721 │\n│ 9   │ Greece            │ 0.975428 │ 1.04479  │ 0.880086 │ 0.941675 │ 0.910409 │ 0.937702 │ 0.851516 │ 0.885416 │ 0.99565  │ 0.892712 │\n│ 10  │ Ireland           │ 1.07683  │ 1.06534  │ 0.974727 │ 1.07845  │ 0.902097 │ 0.824995 │ 1.08184  │ 1.00502  │ 0.974711 │ 0.948907 │\n│ 11  │ Italy             │ 0.966255 │ 1.02578  │ 1.02878  │ 0.980468 │ 0.952348 │ 1.00805  │ 0.894706 │ 1.021    │ 0.931195 │ 1.00194  │\n│ 12  │ Japan             │ 1.02906  │ 1.11366  │ 1.04336  │ 0.869509 │ 1.02776  │ 1.02243  │ 0.971448 │ 0.90699  │ 0.944852 │ 0.94903  │\n│ 13  │ Norway            │ 1.13115  │ 1.1108   │ 0.949576 │ 0.936553 │ 0.904088 │ 0.956691 │ 0.859323 │ 1.16245  │ 0.898815 │ 1.02487  │\n│ 14  │ Spain             │ 0.915789 │ 0.883303 │ 0.996596 │ 1.01146  │ 1.03484  │ 0.991454 │ 1.01437  │ 0.921896 │ 0.849651 │ 1.08936  │\n│ 15  │ Sweden            │ 1.13215  │ 1.2188   │ 1.04962  │ 1.0498   │ 0.878779 │ 1.0206   │ 0.958626 │ 1.00718  │ 1.09563  │ 1.03445  │\n│ 16  │ U.K.              │ 1.04728  │ 1.09075  │ 0.996706 │ 0.998393 │ 0.966998 │ 1.00421  │ 1.00086  │ 1.04238  │ 0.944179 │ 0.9494   │\n│ 17  │ the United States │ 1.05193  │ 1.04846  │ 1.02621  │ 0.955054 │ 1.00271  │ 0.995934 │ 0.940216 │ 0.929503 │ 0.980136 │ 0.964614 │","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"# Focusing on Austria decomposition\nAustriaPIdx = vcat(oecdAnalysis.prodIndexes[2,:]',\n     oecdAnalysis.prodIndexes_G[2,:]',\n     oecdAnalysis.prodIndexes_B[2,:]',\n     oecdAnalysis.prodIndexes_T[2,:]',\n     oecdAnalysis.prodIndexes_E[2,:]',\n     oecdAnalysis.prodIndexes_S[2,:]')\n\nAustriaPIdx   = hcat([\"Overall production indexes\",\n              \"Decomposition for \\\"good\\\" inputs and outputs\",\n              \"Decomposition for \\\"bad\\\" inputs and outputs\",\n              \"Decomposition for the technological component\",\n              \"Decomposition for the efficiency component\",\n              \"Decomposition for the scale (residual) component\",\n              ],AustriaPIdx)\n\n\nAustriaPIdxDf  = DataFrame(AustriaPIdx, Symbol.(vcat(\"Item\",periods[2:end])))","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"│ Row │ Item                                             │ 1981     │ 1982    │ 1983     │ 1984     │ 1985     │ 1986     │ 1987     │ 1988     │ 1989     │ 1990     │\n│     │ Any                                              │ Any      │ Any     │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │ Any      │\n├─────┼──────────────────────────────────────────────────┼──────────┼─────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤\n│ 1   │ Overall production indexes                       │ 0.950153 │ 1.13918 │ 1.08687  │ 0.861064 │ 0.996057 │ 0.96336  │ 1.04583  │ 1.02559  │ 1.00891  │ 0.930929 │\n│ 2   │ Decomposition for \"good\" inputs and outputs      │ 0.969768 │ 0.99197 │ 1.01057  │ 1.0042   │ 1.01544  │ 1.00682  │ 1.01592  │ 1.03277  │ 1.03173  │ 1.02555  │\n│ 3   │ Decomposition for \"bad\" inputs and outputs       │ 0.979773 │ 1.1484  │ 1.0755   │ 0.857465 │ 0.980912 │ 0.956835 │ 1.02945  │ 0.99305  │ 0.977884 │ 0.907733 │\n│ 4   │ Decomposition for the technological component    │ 1.0192   │ 1.0416  │ 1.06671  │ 1.15647  │ 0.96198  │ 1.03854  │ 1.02924  │ 1.1261   │ 1.13558  │ 1.07684  │\n│ 5   │ Decomposition for the efficiency component       │ 0.868255 │ 1.07801 │ 1.06762  │ 0.75353  │ 1.08088  │ 0.955791 │ 1.09237  │ 0.948266 │ 0.976689 │ 0.944898 │\n│ 6   │ Decomposition for the scale (residual) component │ 1.0737   │ 1.01453 │ 0.954357 │ 0.988098 │ 0.957945 │ 0.970511 │ 0.930198 │ 0.960434 │ 0.909664 │ 0.914914 │","category":"page"},{"location":"index.html#Production-indexes-considering-a-fixed-base","page":"Index","title":"Production indexes considering a fixed base","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Similarly, we can compute the production index with reference to a fixed base, both in term of specific DMU and period. For example, if we consider as reference base the US observation for 1989 we have:","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"# Performing the analysis\noecdAnalysisFB  = prodIndexFB(gI,gO,bO,bI;remarcable_obs_dmu=17,remarcable_obs_period=10);\npIdx = oecdAnalysisFB.prodIndexes;\n\n# Add periods as headers and decision making names as first column in order to show the data\n# Efficiency Indexes\npIdx  = hcat(dmus,pIdx);\npIdxDf = DataFrame(pIdx, Symbol.(vcat(\"Country\",periods)))","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":" Row │ Country            1980         1981         1982         1983         1984         1985         1986         1987         1988         1989         1990        \n     │ Any                Any          Any          Any          Any          Any          Any          Any          Any          Any          Any          Any         \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Australia          0.000990747  0.00102238   0.00104535   0.00106707   0.0011966    0.00134927   0.00137213   0.00153062   0.00170403   0.00190516   0.00202583\n   2 │ Austria            0.000103987  0.000103968  9.0544e-5    8.53889e-5   0.00010007   0.000103614  0.000109087  0.000107653  0.000111959  0.000118265  0.000133616\n   3 │ Belgium            0.000548718  0.000512234  0.000458746  0.000381597  0.000410967  0.000426637  0.000444979  0.000451222  0.000465334  0.000512454  0.000569875\n   4 │ Canada             0.00832702   0.00790575   0.00662924   0.00675101   0.00772083   0.00882244   0.00891513   0.00979034   0.0118275    0.0126891    0.0115645\n   5 │ Denmark            8.21952e-5   6.84335e-5   6.17971e-5   5.65799e-5   6.41921e-5   8.4313e-5    8.54746e-5   8.76725e-5   7.98611e-5   7.8859e-5    7.46455e-5\n   6 │ Finland            8.12688e-5   7.86115e-5   6.68769e-5   6.49423e-5   6.62465e-5   7.61118e-5   7.96103e-5   9.31865e-5   9.68827e-5   0.00011073   0.00011347\n   7 │ France             0.00754285   0.00644225   0.00596744   0.00580938   0.00561904   0.00592596   0.00565579   0.0057622    0.00555473   0.00638032   0.00672812\n   8 │ Germany            0.0154787    0.0137312    0.0126993    0.0129362    0.0134858    0.0139653    0.0151107    0.0149917    0.0153983    0.0142087    0.0155073\n   9 │ Greece             4.32324e-5   4.27438e-5   4.09761e-5   4.48322e-5   4.8327e-5    5.60026e-5   5.97699e-5   6.86058e-5   8.28546e-5   8.98524e-5   0.000101018\n  10 │ Ireland            8.83073e-6   8.32965e-6   7.71712e-6   7.35993e-6   7.1506e-6    8.16134e-6   9.54632e-6   9.53161e-6   1.03376e-5   1.22625e-5   1.50621e-5\n  11 │ Italy              0.00413459   0.00411261   0.00388937   0.00372799   0.00393073   0.00423347   0.00436165   0.00508875   0.00529599   0.00587679   0.00595866\n  12 │ Japan              0.0157031    0.0156941    0.014342     0.0138899    0.0167466    0.0173988    0.0171764    0.0184454    0.0221081    0.0245773    0.0273242\n  13 │ Norway             7.61648e-5   6.70166e-5   5.88881e-5   6.68082e-5   7.83479e-5   9.38574e-5   0.000103544  0.000120039  9.98515e-5   0.000107198  0.000106517\n  14 │ Spain              0.00101654   0.00103208   0.00115287   0.00114513   0.00109003   0.00106861   0.00112689   0.00119822   0.00137574   0.00168567   0.00156616\n  15 │ Sweden             0.000302108  0.000255463  0.000209698  0.000203095  0.000207004  0.000241194  0.000241541  0.000256412  0.000254944  0.000233936  0.000221067\n  16 │ U.K.               0.00809758   0.00716331   0.00660083   0.00705684   0.00729171   0.0078856    0.00842427   0.00907481   0.00949474   0.0102033    0.0103832\n  17 │ the United States  0.75476      0.725291     0.628489     0.638697     0.747291     0.759032     0.774467     0.844417     0.951598     1.0          1.01465","category":"page"},{"location":"index.html#Vanilla-DEA-Example","page":"Index","title":"Vanilla DEA Example","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"BDisposal provides also a simple function for \"vanilla\" DEA computation. In this example we have 4 DMU with two inputs and one output, and we compute the efficiency of the latest DMU:","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"I  = [10   2;\n       8   4;\n      12 1.5;\n      24   3]\nO =  [100;80;120;120]\nI₀ = [24 3]\nO₀ = [120]\n\nresults = dmuEfficiency(I₀,O₀,I,O)","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"(computed = true, eff = false, obj = 0.5, wI = [0.041666666666666664, 0.0], wO = [0.004166666666666667], refSet = Dict(3 => 1.0), othDMUsEffConstrDuals = [0.0, 0.0, 1.0, 0.0], iRegConstrDual = 0.5)","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"Here we see that the last DMU is not efficient (indeed it's coefficient is only 0.5) as it is \"dominated\" by the third DMU that is the only efficient DMU in this set.","category":"page"},{"location":"index.html#Other-packages","page":"Index","title":"Other packages","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"This is a list of other Julia packages that use classical DEA method, although without relaxing the disposability assumption.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"DataEnvelopmentAnalysis.jl\nFrontierEfficiencyAnalysis.jl\nSearchRef.jl\nJuMP4DEA.jl","category":"page"},{"location":"index.html#References","page":"Index","title":"References","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Abad, A. (2020) Environmental Efficiency and Productivity Analysis, HAL, 03032038\nAbad, A., P. Ravelojaona (2020a) Pollution-adjusted Productivity Analysis: The Use of Malmquist and Luenberger Productivity Measures, Managerial and Decision Economics\nAbad, A., P. Ravelojoana (2020b) A Generalization of Environmental Productivity Analysis, HAL, 02964799\nAbad, A., W. Briec (2019) On the Axiomatic of Pollution-generating Technologies: a Non-Parametric Approach, European Journal of Operational Research, 277(1), 377-390\nAbad, A. (2018) Les Enseignements de la Micro-économie de la Production face aux Enjeux Environnementaux: Etude des Productions Jointes. Théorie et Applications, Ph.D dissertation, University of Perpignan.\nAbad, A., P. Ravelojaona (2017) Exponential environmental productivity index and indicators, Journal of Productivity Analysis, 48(2), 147-166.\nAbad, A. (2015) An environmental generalised Luenberger-Hicks-Moorsteen productivity indicator and an environmental generalised Hicks-Moorsteen productivity index, Journal of Environmental Management, 161, 325-334.","category":"page"},{"location":"index.html#Acknowledgements","page":"Index","title":"Acknowledgements","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"The development of this package at the Bureau d'Economie Théorique et Appliquée (BETA, Nancy) was supported by the French National Research Agency through the Laboratory of Excellence ARBRE, a part of the “Investissements d'Avenir” Program (ANR 11 – LABX-0002-01).","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"(Image: BLogos)","category":"page"},{"location":"prodIndexFB.html#Finding-the-Production-Indexes-under-a-provided-Fixed-Base","page":"Fixed base Productivity Index","title":"Finding the Production Indexes under a provided Fixed Base","text":"","category":"section"},{"location":"prodIndexFB.html","page":"Fixed base Productivity Index","title":"Fixed base Productivity Index","text":"prodIndexFB","category":"page"},{"location":"prodIndexFB.html#BDisposal.prodIndexFB","page":"Fixed base Productivity Index","title":"BDisposal.prodIndexFB","text":"prodIndexFB(gI,gO,bO,bI;remarcable_obs_dmu,remarcable_obs_period)\n\nCompute productivity indexes with a fixed base.\n\nGiven a set of measures of inputs, \"good\" (\"desiderable\") and \"bad\" (\"undesiderable\") outputs for different decision making units, and a specific dmu/time observation to consider as base (\"remarcable\"), provides the productivity indexes at various time periods.\n\nParameters:\n\nPositional\ngI: \"Good\" inputs (3D array by DMUs, input items and periods)\ngO: \"Good\" outputs (3D array by DMUs, input items and periods)\nbO: \"Bad\" outputs (3D array by DMUs, input items and periods)\nbI: \"Bad\" inputs (optional 3D array by DMUs, input items and periods) [default: empty array]\nKeyword\nremarcable_obs_dmu: Which observation to consider the \"remarcable\" one [def: 1]\nremarcable_obs_period: Which tipe period to consider the \"remarcable\" one [def: 1`]\n\nReturns:\n\nA named touple where each element is a matrix of base-related production indexes by DMUs and time periods.\nCurrently the value reported are:\nprodIndexes:          Overall production indexes\n\nDescription of the function\n\nprodIndexFB is a fixed base version of the multiplicative prodIndex function. As a result, prodIndexFB is based upon the identification of a fixed base observation allowing to compare spatial and/or temporal observations. Specifically, the choice of the base observation for comparisons is affected by the identification of remarkable spatial and/or temporal units.\n\nInterpretation of the results\n\nprodIndexFB > 1 indicates environmentally-adjusted performance improvement. In such case, the remarkable observation produces more good outputs and less bad goods than the compared observation for a given level of good and bad inputs. Alongside, less good and bad inputs are employed by the remarkable observation relatively to the compared observation for given good and bad outputs. If prodIndexFB < 1, the reverse reasonning holds.\n\nExample\n\njulia> using BDisposal\njulia> # 2 DMUs, 2 good Inputs, 2 bad inputs, 3 good outputs and 2 bad outputs. 2 periods\n       gI = [1; 3; 5;; 2; 4; 5;;; 1; 4; 5;; 2; 5; 5];\njulia> bI = [2; 4; 2;; 3; 7; 5;;; 2; 3; 2;; 3; 6; 5];\njulia> gO = [10; 30; 50;; 20; 40; 50;; 15; 8; 12;;; 12; 40; 50;; 22; 50; 50;; 16; 55; 55];\njulia> bO = [2; 4; 2;; 3; 7; 5;;; 2; 3; 2;; 3; 6; 5];\njulia> analysis = prodIndexFB(gI,gO,bO,bI;remarcable_obs_dmu=1, remarcable_obs_period=2);\njulia> analysis.prodIndexes\n3×2 Matrix{Union{Missing, Float64}}:\n 0.909091  1.0\n 3.63636   2.33766\n 1.2987    1.2987\n\nNotes:\n\nThe function assumes convex, multiplicative production functions with variable returns to scale\n\n\n\n\n\n","category":"function"}]
}
